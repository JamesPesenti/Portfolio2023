{"ast":null,"code":"import { CommonActions, getActionFromState, StackActions } from \"@react-navigation/core\";\nimport { TabActions } from \"@react-navigation/native\";\nimport * as Linking from \"expo-linking\";\nimport { resolveHref } from \"../link/href\";\nimport { resolve } from \"../link/path\";\nimport { findTopRouteForTarget, getEarliestMismatchedRoute, getQualifiedStateForTopOfTargetState, isMovingToSiblingRoute } from \"../link/stateOperations\";\nfunction assertIsReady(store) {\n  if (!store.isReady || !store.navigationRef.current) {\n    throw new Error(\"Attempted to use navigation outside of Expo Router\");\n  }\n}\nexport function push(url) {\n  return this.linkTo(resolveHref(url));\n}\nexport function replace(url) {\n  return this.linkTo(resolveHref(url), \"REPLACE\");\n}\nexport function goBack() {\n  var _this$navigationRef, _this$navigationRef$c;\n  assertIsReady(this);\n  (_this$navigationRef = this.navigationRef) == null ? void 0 : (_this$navigationRef$c = _this$navigationRef.current) == null ? void 0 : _this$navigationRef$c.goBack();\n}\nexport function setParams() {\n  var _this$navigationRef2, _this$navigationRef2$;\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  assertIsReady(this);\n  return ((_this$navigationRef2 = this.navigationRef) == null ? void 0 : (_this$navigationRef2$ = _this$navigationRef2.current) == null ? void 0 : _this$navigationRef2$.setParams.bind(_this$navigationRef2$))(params);\n}\nexport function linkTo(href, event) {\n  if (isRemoteHref(href)) {\n    Linking.openURL(href);\n    return;\n  }\n  assertIsReady(this);\n  var navigationRef = this.navigationRef.current;\n  if (navigationRef == null) {\n    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n  }\n  if (!this.linking) {\n    throw new Error(\"Attempted to link to route when no routes are present\");\n  }\n  if (href === \"..\" || href === \"../\") {\n    navigationRef.goBack();\n    return;\n  }\n  if (href.startsWith(\".\")) {\n    var _this$linking$getPath, _this$linking$getPath2, _this$linking;\n    var base = (_this$linking$getPath = (_this$linking$getPath2 = (_this$linking = this.linking).getPathFromState) == null ? void 0 : _this$linking$getPath2.call(_this$linking, navigationRef.getRootState(), {\n      screens: [],\n      preserveGroups: true\n    })) != null ? _this$linking$getPath : \"\";\n    if (base && !base.endsWith(\"/\")) {\n      base += \"/..\";\n    }\n    href = resolve(base, href);\n  }\n  var state = this.linking.getStateFromPath(href, this.linking.config);\n  if (!state) {\n    console.error(\"Could not generate a valid navigation state for the given path: \" + href);\n    return;\n  }\n  var rootState = navigationRef.getRootState();\n  if (isMovingToSiblingRoute(rootState, state)) {\n    var knownOwnerState = getQualifiedStateForTopOfTargetState(rootState, state);\n    var nextRoute = findTopRouteForTarget(state);\n    if (knownOwnerState.type === \"tab\") {\n      navigationRef.dispatch(TabActions.jumpTo(nextRoute.name, nextRoute.params));\n      return;\n    } else {\n      if (event === \"REPLACE\") {\n        navigationRef.dispatch(StackActions.replace(nextRoute.name, nextRoute.params));\n      } else {\n        navigationRef.dispatch(CommonActions.navigate(nextRoute.name, nextRoute.params));\n      }\n      return;\n    }\n  }\n  var action = getActionFromState(state, this.linking.config);\n  if (action) {\n    if (event === \"REPLACE\" && isAbsoluteInitialRoute(action)) {\n      var earliest = getEarliestMismatchedRoute(rootState, action.payload);\n      if (earliest) {\n        if (earliest.type === \"stack\") {\n          navigationRef.dispatch(StackActions.replace(earliest.name, earliest.params));\n        } else {\n          navigationRef.dispatch(TabActions.jumpTo(earliest.name, earliest.params));\n        }\n        return;\n      } else {}\n    }\n    navigationRef.dispatch(action);\n  } else {\n    navigationRef.reset(state);\n  }\n}\nfunction isRemoteHref(href) {\n  return /:\\/\\//.test(href);\n}\nexport function isAbsoluteInitialRoute(action) {\n  if ((action == null ? void 0 : action.type) !== \"NAVIGATE\") {\n    return false;\n  }\n  var next = action.payload.params;\n  while (next) {\n    if (!isNavigationState(next)) {\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isNavigationState(obj) {\n  return \"initial\" in obj;\n}","map":{"version":3,"names":["CommonActions","getActionFromState","StackActions","TabActions","Linking","resolveHref","resolve","findTopRouteForTarget","getEarliestMismatchedRoute","getQualifiedStateForTopOfTargetState","isMovingToSiblingRoute","assertIsReady","store","isReady","navigationRef","current","Error","push","url","linkTo","replace","goBack","setParams","params","href","event","isRemoteHref","openURL","linking","startsWith","base","getPathFromState","getRootState","screens","preserveGroups","endsWith","state","getStateFromPath","config","console","error","rootState","knownOwnerState","nextRoute","type","dispatch","jumpTo","name","navigate","action","isAbsoluteInitialRoute","earliest","payload","reset","test","next","isNavigationState","initial","obj"],"sources":["C:/Users/jimpe/Desktop/react_native_apps/Portfolio2023/node_modules/expo-router/src/global-state/routing.ts"],"sourcesContent":["import {\n  CommonActions,\n  getActionFromState,\n  StackActions,\n} from \"@react-navigation/core\";\nimport { TabActions } from \"@react-navigation/native\";\nimport * as Linking from \"expo-linking\";\n\nimport { Href, resolveHref } from \"../link/href\";\nimport { resolve } from \"../link/path\";\nimport {\n  NavigateAction,\n  findTopRouteForTarget,\n  getEarliestMismatchedRoute,\n  getQualifiedStateForTopOfTargetState,\n  isMovingToSiblingRoute,\n} from \"../link/stateOperations\";\nimport type { RouterStore } from \"./router-store\";\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.isReady || !store.navigationRef.current) {\n    throw new Error(\"Attempted to use navigation outside of Expo Router\");\n  }\n}\n\nexport function push(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url));\n}\n\nexport function replace(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), \"REPLACE\");\n}\n\nexport function goBack(this: RouterStore) {\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function setParams(\n  this: RouterStore,\n  params: Record<string, string | number> = {}\n) {\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport function linkTo(this: RouterStore, href: string, event?: string) {\n  if (isRemoteHref(href)) {\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error(\"Attempted to link to route when no routes are present\");\n  }\n\n  if (href === \"..\" || href === \"../\") {\n    navigationRef.goBack();\n    return;\n  }\n\n  if (href.startsWith(\".\")) {\n    let base =\n      this.linking.getPathFromState?.(navigationRef.getRootState(), {\n        screens: [],\n        preserveGroups: true,\n      }) ?? \"\";\n\n    if (base && !base.endsWith(\"/\")) {\n      base += \"/..\";\n    }\n    href = resolve(base, href);\n  }\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state) {\n    console.error(\n      \"Could not generate a valid navigation state for the given path: \" + href\n    );\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  // Ensure simple operations are used when moving between siblings\n  // in the same navigator. This ensures that the state is not reset.\n  // TODO: We may need to apply this at a larger scale in the future.\n  if (isMovingToSiblingRoute(rootState, state)) {\n    // Can perform naive movements\n    const knownOwnerState = getQualifiedStateForTopOfTargetState(\n      rootState,\n      state\n    )!;\n    const nextRoute = findTopRouteForTarget(state);\n\n    if (knownOwnerState.type === \"tab\") {\n      navigationRef.dispatch(\n        TabActions.jumpTo(nextRoute.name, nextRoute.params)\n      );\n      return;\n    } else {\n      if (event === \"REPLACE\") {\n        navigationRef.dispatch(\n          StackActions.replace(nextRoute.name, nextRoute.params)\n        );\n      } else {\n        // NOTE: Not sure if we should pop or push here...\n        navigationRef.dispatch(\n          CommonActions.navigate(nextRoute.name, nextRoute.params)\n        );\n      }\n      return;\n    }\n  }\n\n  // TODO: Advanced movements across multiple navigators\n\n  const action = getActionFromState(state, this.linking.config);\n  if (action) {\n    // Here we have a navigation action to a nested screen, where we should ideally replace.\n    // This request can only be fulfilled if the target is an initial route.\n    // First, check if the action is fully initial routes.\n    // Then find the nearest mismatched route in the existing state.\n    // Finally, use the correct navigator-based action to replace the nested screens.\n    // NOTE(EvanBacon): A future version of this will involve splitting the navigation request so we replace as much as possible, then push the remaining screens to fulfill the request.\n    if (event === \"REPLACE\" && isAbsoluteInitialRoute(action)) {\n      const earliest = getEarliestMismatchedRoute(rootState, action.payload);\n      if (earliest) {\n        if (earliest.type === \"stack\") {\n          navigationRef.dispatch(\n            StackActions.replace(earliest.name, earliest.params)\n          );\n        } else {\n          navigationRef.dispatch(\n            TabActions.jumpTo(earliest.name, earliest.params)\n          );\n        }\n        return;\n      } else {\n        // This should never happen because moving to the same route would be handled earlier\n        // in the sibling operations.\n      }\n    }\n\n    // Ignore the replace event here since replace across\n    // navigators is not supported.\n    navigationRef.dispatch(action);\n  } else {\n    navigationRef.reset(state);\n  }\n}\n\nfunction isRemoteHref(href: string): boolean {\n  return /:\\/\\//.test(href);\n}\n\n/** @returns `true` if the action is moving to the first screen of all the navigators in the action. */\nexport function isAbsoluteInitialRoute(\n  action: ReturnType<typeof getActionFromState>\n): action is NavigateAction {\n  if (action?.type !== \"NAVIGATE\") {\n    return false;\n  }\n\n  let next = action.payload.params;\n  // iterate all child screens and bail out if any are not initial.\n  while (next) {\n    if (!isNavigationState(next)) {\n      // Not sure when this would happen\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n      // return true;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype NavStateParams = {\n  params?: NavStateParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  state: unknown;\n};\n\nfunction isNavigationState(obj: any): obj is NavStateParams {\n  return \"initial\" in obj;\n}\n"],"mappings":"AAAA,SACEA,aAAa,EACbC,kBAAkB,EAClBC,YAAY,QACP,wBAAwB;AAC/B,SAASC,UAAU,QAAQ,0BAA0B;AACrD,OAAO,KAAKC,OAAO,MAAM,cAAc;AAEvC,SAAeC,WAAW;AAC1B,SAASC,OAAO;AAChB,SAEEC,qBAAqB,EACrBC,0BAA0B,EAC1BC,oCAAoC,EACpCC,sBAAsB;AAIxB,SAASC,aAAa,CAACC,KAAkB,EAAE;EACzC,IAAI,CAACA,KAAK,CAACC,OAAO,IAAI,CAACD,KAAK,CAACE,aAAa,CAACC,OAAO,EAAE;IAClD,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;EACvE;AACF;AAEA,OAAO,SAASC,IAAI,CAAoBC,GAAS,EAAE;EACjD,OAAO,IAAI,CAACC,MAAM,CAACd,WAAW,CAACa,GAAG,CAAC,CAAC;AACtC;AAEA,OAAO,SAASE,OAAO,CAAoBF,GAAS,EAAE;EACpD,OAAO,IAAI,CAACC,MAAM,CAACd,WAAW,CAACa,GAAG,CAAC,EAAE,SAAS,CAAC;AACjD;AAEA,OAAO,SAASG,MAAM,GAAoB;EAAA;EACxCV,aAAa,CAAC,IAAI,CAAC;EACnB,2BAAI,CAACG,aAAa,8CAAlB,oBAAoBC,OAAO,qBAA3B,sBAA6BM,MAAM,EAAE;AACvC;AAEA,OAAO,SAASC,SAAS,GAGvB;EAAA;EAAA,IADAC,MAAuC,uEAAG,CAAC,CAAC;EAE5CZ,aAAa,CAAC,IAAI,CAAC;EACnB,OAAO,yBAAC,IAAI,CAACG,aAAa,8CAAlB,qBAAoBC,OAAO,qBAA3B,sBAA6BO,SAAS,8BAASC,MAAM,CAAC;AAChE;AAEA,OAAO,SAASJ,MAAM,CAAoBK,IAAY,EAAEC,KAAc,EAAE;EACtE,IAAIC,YAAY,CAACF,IAAI,CAAC,EAAE;IACtBpB,OAAO,CAACuB,OAAO,CAACH,IAAI,CAAC;IACrB;EACF;EAEAb,aAAa,CAAC,IAAI,CAAC;EACnB,IAAMG,aAAa,GAAG,IAAI,CAACA,aAAa,CAACC,OAAO;EAEhD,IAAID,aAAa,IAAI,IAAI,EAAE;IACzB,MAAM,IAAIE,KAAK,CACb,kFAAkF,CACnF;EACH;EAEA,IAAI,CAAC,IAAI,CAACY,OAAO,EAAE;IACjB,MAAM,IAAIZ,KAAK,CAAC,uDAAuD,CAAC;EAC1E;EAEA,IAAIQ,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,EAAE;IACnCV,aAAa,CAACO,MAAM,EAAE;IACtB;EACF;EAEA,IAAIG,IAAI,CAACK,UAAU,CAAC,GAAG,CAAC,EAAE;IAAA;IACxB,IAAIC,IAAI,sDACN,qBAAI,CAACF,OAAO,EAACG,gBAAgB,qBAA7B,2CAAgCjB,aAAa,CAACkB,YAAY,EAAE,EAAE;MAC5DC,OAAO,EAAE,EAAE;MACXC,cAAc,EAAE;IAClB,CAAC,CAAC,oCAAI,EAAE;IAEV,IAAIJ,IAAI,IAAI,CAACA,IAAI,CAACK,QAAQ,CAAC,GAAG,CAAC,EAAE;MAC/BL,IAAI,IAAI,KAAK;IACf;IACAN,IAAI,GAAGlB,OAAO,CAACwB,IAAI,EAAEN,IAAI,CAAC;EAC5B;EAEA,IAAMY,KAAK,GAAG,IAAI,CAACR,OAAO,CAACS,gBAAgB,CAAEb,IAAI,EAAE,IAAI,CAACI,OAAO,CAACU,MAAM,CAAC;EAEvE,IAAI,CAACF,KAAK,EAAE;IACVG,OAAO,CAACC,KAAK,CACX,kEAAkE,GAAGhB,IAAI,CAC1E;IACD;EACF;EAEA,IAAMiB,SAAS,GAAG3B,aAAa,CAACkB,YAAY,EAAE;EAK9C,IAAItB,sBAAsB,CAAC+B,SAAS,EAAEL,KAAK,CAAC,EAAE;IAE5C,IAAMM,eAAe,GAAGjC,oCAAoC,CAC1DgC,SAAS,EACTL,KAAK,CACL;IACF,IAAMO,SAAS,GAAGpC,qBAAqB,CAAC6B,KAAK,CAAC;IAE9C,IAAIM,eAAe,CAACE,IAAI,KAAK,KAAK,EAAE;MAClC9B,aAAa,CAAC+B,QAAQ,CACpB1C,UAAU,CAAC2C,MAAM,CAACH,SAAS,CAACI,IAAI,EAAEJ,SAAS,CAACpB,MAAM,CAAC,CACpD;MACD;IACF,CAAC,MAAM;MACL,IAAIE,KAAK,KAAK,SAAS,EAAE;QACvBX,aAAa,CAAC+B,QAAQ,CACpB3C,YAAY,CAACkB,OAAO,CAACuB,SAAS,CAACI,IAAI,EAAEJ,SAAS,CAACpB,MAAM,CAAC,CACvD;MACH,CAAC,MAAM;QAELT,aAAa,CAAC+B,QAAQ,CACpB7C,aAAa,CAACgD,QAAQ,CAACL,SAAS,CAACI,IAAI,EAAEJ,SAAS,CAACpB,MAAM,CAAC,CACzD;MACH;MACA;IACF;EACF;EAIA,IAAM0B,MAAM,GAAGhD,kBAAkB,CAACmC,KAAK,EAAE,IAAI,CAACR,OAAO,CAACU,MAAM,CAAC;EAC7D,IAAIW,MAAM,EAAE;IAOV,IAAIxB,KAAK,KAAK,SAAS,IAAIyB,sBAAsB,CAACD,MAAM,CAAC,EAAE;MACzD,IAAME,QAAQ,GAAG3C,0BAA0B,CAACiC,SAAS,EAAEQ,MAAM,CAACG,OAAO,CAAC;MACtE,IAAID,QAAQ,EAAE;QACZ,IAAIA,QAAQ,CAACP,IAAI,KAAK,OAAO,EAAE;UAC7B9B,aAAa,CAAC+B,QAAQ,CACpB3C,YAAY,CAACkB,OAAO,CAAC+B,QAAQ,CAACJ,IAAI,EAAEI,QAAQ,CAAC5B,MAAM,CAAC,CACrD;QACH,CAAC,MAAM;UACLT,aAAa,CAAC+B,QAAQ,CACpB1C,UAAU,CAAC2C,MAAM,CAACK,QAAQ,CAACJ,IAAI,EAAEI,QAAQ,CAAC5B,MAAM,CAAC,CAClD;QACH;QACA;MACF,CAAC,MAAM,CAGP;IACF;IAIAT,aAAa,CAAC+B,QAAQ,CAACI,MAAM,CAAC;EAChC,CAAC,MAAM;IACLnC,aAAa,CAACuC,KAAK,CAACjB,KAAK,CAAC;EAC5B;AACF;AAEA,SAASV,YAAY,CAACF,IAAY,EAAW;EAC3C,OAAO,OAAO,CAAC8B,IAAI,CAAC9B,IAAI,CAAC;AAC3B;AAGA,OAAO,SAAS0B,sBAAsB,CACpCD,MAA6C,EACnB;EAC1B,IAAI,CAAAA,MAAM,oBAANA,MAAM,CAAEL,IAAI,MAAK,UAAU,EAAE;IAC/B,OAAO,KAAK;EACd;EAEA,IAAIW,IAAI,GAAGN,MAAM,CAACG,OAAO,CAAC7B,MAAM;EAEhC,OAAOgC,IAAI,EAAE;IACX,IAAI,CAACC,iBAAiB,CAACD,IAAI,CAAC,EAAE;MAE5B,OAAO,KAAK;IACd;IACA,IAAIA,IAAI,CAACE,OAAO,KAAK,IAAI,EAAE;MACzBF,IAAI,GAAGA,IAAI,CAAChC,MAAM;IAEpB,CAAC,MAAM,IAAIgC,IAAI,CAACE,OAAO,KAAK,KAAK,EAAE;MACjC,OAAO,KAAK;IACd;EACF;EAEA,OAAO,IAAI;AACb;AAUA,SAASD,iBAAiB,CAACE,GAAQ,EAAyB;EAC1D,OAAO,SAAS,IAAIA,GAAG;AACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}