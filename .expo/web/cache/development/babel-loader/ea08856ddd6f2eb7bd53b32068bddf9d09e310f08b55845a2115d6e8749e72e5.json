{"ast":null,"code":"function findTopStateForTarget(state) {\n  var current = state;\n  while (((_current = current) == null ? void 0 : (_current$routes = _current.routes) == null ? void 0 : _current$routes[((_current2 = current) == null ? void 0 : (_current2$routes = _current2.routes) == null ? void 0 : _current2$routes.length) - 1].state) != null) {\n    var _current, _current$routes, _current2, _current2$routes, _current3, _current4;\n    current = (_current3 = current) == null ? void 0 : _current3.routes[((_current4 = current) == null ? void 0 : _current4.routes.length) - 1].state;\n  }\n  return current;\n}\nexport function findTopRouteForTarget(state) {\n  var _nextState$routes;\n  var nextState = findTopStateForTarget(state);\n  return (_nextState$routes = nextState.routes) == null ? void 0 : _nextState$routes[nextState.routes.length - 1];\n}\nexport function isMovingToSiblingRoute(currentState, targetState) {\n  var _currentState$routeNa;\n  if (!currentState || !targetState) {\n    return false;\n  }\n  var targetRoute = targetState.routes[0];\n  if (!((_currentState$routeNa = currentState.routeNames) != null && _currentState$routeNa.includes(targetRoute.name))) {\n    return false;\n  }\n  if (!targetRoute.state) {\n    return true;\n  }\n  var currentRoutes = currentState == null ? void 0 : currentState.routes;\n  var locatedState = currentRoutes == null ? void 0 : currentRoutes.find(function (r) {\n    return r.name === targetRoute.name;\n  });\n  if (!locatedState) {\n    return false;\n  }\n  return isMovingToSiblingRoute(locatedState.state, targetRoute.state);\n}\nexport function getQualifiedStateForTopOfTargetState(rootState, targetState) {\n  var current = targetState;\n  var currentRoot = rootState;\n  var _loop = function _loop() {\n      var _current7, _current7$routes, _current8, _current8$routes, _currentRoot, _currentRoot$routes, _currentRoot$routes$f;\n      var nextRoute = (_current7 = current) == null ? void 0 : (_current7$routes = _current7.routes) == null ? void 0 : _current7$routes[((_current8 = current) == null ? void 0 : (_current8$routes = _current8.routes) == null ? void 0 : _current8$routes.length) - 1];\n      var nextCurrentRoot = (_currentRoot = currentRoot) == null ? void 0 : (_currentRoot$routes = _currentRoot.routes) == null ? void 0 : (_currentRoot$routes$f = _currentRoot$routes.find(function (route) {\n        return route.name === nextRoute.name;\n      })) == null ? void 0 : _currentRoot$routes$f.state;\n      if (nextCurrentRoot == null) {\n        return {\n          v: currentRoot\n        };\n      } else {\n        currentRoot = nextCurrentRoot;\n      }\n      current = nextRoute.state;\n    },\n    _ret;\n  while (((_current5 = current) == null ? void 0 : (_current5$routes = _current5.routes) == null ? void 0 : _current5$routes[((_current6 = current) == null ? void 0 : (_current6$routes = _current6.routes) == null ? void 0 : _current6$routes.length) - 1].state) != null) {\n    var _current5, _current5$routes, _current6, _current6$routes;\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n  return currentRoot;\n}\nexport function getEarliestMismatchedRoute(rootState, actionParams) {\n  var _actionParams$name;\n  var actionName = (_actionParams$name = actionParams.name) != null ? _actionParams$name : actionParams.screen;\n  if (!(rootState != null && rootState.routes) || rootState.index == null) {\n    return {\n      name: actionName,\n      type: \"stack\"\n    };\n  }\n  var nextCurrentRoot = rootState.routes[rootState.index];\n  if (actionName === nextCurrentRoot.name) {\n    if (!actionParams.params) {\n      return null;\n    }\n    return getEarliestMismatchedRoute(nextCurrentRoot.state, actionParams.params);\n  }\n  return {\n    name: actionName,\n    params: actionParams.params,\n    type: rootState.type\n  };\n}","map":{"version":3,"names":["findTopStateForTarget","state","current","routes","length","findTopRouteForTarget","nextState","isMovingToSiblingRoute","currentState","targetState","targetRoute","routeNames","includes","name","currentRoutes","locatedState","find","r","getQualifiedStateForTopOfTargetState","rootState","currentRoot","nextRoute","nextCurrentRoot","route","getEarliestMismatchedRoute","actionParams","actionName","screen","index","type","params"],"sources":["C:/Users/jimpe/Desktop/react_native_apps/Portfolio2023/node_modules/expo-router/src/link/stateOperations.ts"],"sourcesContent":["import {\n  InitialState,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n  getActionFromState,\n} from \"@react-navigation/native\";\n\nimport { ResultState } from \"../fork/getStateFromPath\";\n\nexport type NavigateAction = Extract<\n  ReturnType<typeof getActionFromState>,\n  { type: \"NAVIGATE\" }\n> & {\n  payload: NavigateActionParams;\n};\n\nexport type NavigateActionParams = {\n  params?: NavigateActionParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  name?: string;\n};\n\n// Get the last state for a given target state (generated from a path).\nfunction findTopStateForTarget(state: ResultState) {\n  let current: Partial<InitialState> | undefined = state;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    current = current?.routes[current?.routes.length - 1].state;\n  }\n\n  return current;\n}\n\n/** Return the absolute last route to move to. */\nexport function findTopRouteForTarget(state: ResultState) {\n  const nextState = findTopStateForTarget(state)!;\n  // Ensure we get the last route to prevent returning the initial route.\n  return nextState.routes?.[nextState.routes.length - 1]!;\n}\n\n/** @returns true if moving to a sibling inside the same navigator. */\nexport function isMovingToSiblingRoute(\n  currentState: NavigationState | PartialState<NavigationState> | undefined,\n  targetState: ResultState | undefined\n): boolean {\n  if (!currentState || !targetState) {\n    return false;\n  }\n\n  // Need to type this, as the current types are not compaitble with the `find`\n  const targetRoute = targetState.routes[0];\n\n  // Make sure we're in the same navigator\n  if (!currentState.routeNames?.includes(targetRoute.name)) {\n    return false;\n  }\n\n  // If there's no state, we're at the end of the path\n  if (!targetRoute.state) {\n    return true;\n  }\n\n  // Coerce the types into a more common form\n  const currentRoutes:\n    | {\n        name: string;\n        state?: NavigationState | PartialState<NavigationState>;\n      }[]\n    | undefined = currentState?.routes;\n  const locatedState = currentRoutes?.find((r) => r.name === targetRoute.name);\n\n  if (!locatedState) {\n    return false;\n  }\n\n  return isMovingToSiblingRoute(locatedState.state, targetRoute.state);\n}\n\n// Given the root state and a target state from `getStateFromPath`,\n// return the root state containing the highest target route matching the root state.\n// This can be used to determine what type of navigator action should be used.\nexport function getQualifiedStateForTopOfTargetState(\n  rootState: InitialState,\n  targetState: ResultState\n) {\n  let current: InitialState | undefined = targetState;\n  let currentRoot: InitialState | undefined = rootState;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    const nextRoute: any = current?.routes?.[current?.routes?.length - 1];\n\n    const nextCurrentRoot: InitialState | undefined = currentRoot?.routes?.find(\n      (route) => route.name === nextRoute.name\n    )?.state;\n\n    if (nextCurrentRoot == null) {\n      return currentRoot;\n      // Not sure what to do -- we're tracking against the assumption that\n      // all routes in the target state are in the root state\n      // currentRoot = undefined;\n    } else {\n      currentRoot = nextCurrentRoot;\n    }\n\n    current = nextRoute.state;\n  }\n\n  return currentRoot;\n}\n\n// Given the root state and a target state from `getStateFromPath`,\n// return the root state containing the highest target route matching the root state.\n// This can be used to determine what type of navigator action should be used.\nexport function getEarliestMismatchedRoute<T extends ParamListBase>(\n  rootState: NavigationState<T> | undefined,\n  actionParams: NavigateActionParams\n): { name: string; params?: any; type?: string } | null {\n  const actionName = actionParams.name ?? actionParams.screen;\n  if (!rootState?.routes || rootState.index == null) {\n    // This should never happen where there's more action than state.\n    return {\n      name: actionName,\n      type: \"stack\",\n    };\n  }\n\n  const nextCurrentRoot = rootState.routes[rootState.index];\n  if (actionName === nextCurrentRoot.name) {\n    if (!actionParams.params) {\n      // All routes match all the way up, no change required.\n      return null;\n    }\n\n    return getEarliestMismatchedRoute(\n      // @react-navigation/native types this as NavigationState | Partial<NavigationState> | undefined\n      // In our usage, it's always a NavigationState | undefined\n      nextCurrentRoot.state as NavigationState<T> | undefined,\n      actionParams.params\n    );\n  }\n\n  // There's a selected state but it doesn't match the action state\n  // this is now the lowest point of change.\n  return {\n    name: actionName,\n    params: actionParams.params,\n    type: rootState.type,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}