{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport * as SplashModule from \"expo-splash-screen\";\nimport { nanoid } from \"nanoid/non-secure\";\nimport * as React from \"react\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nvar globalStack = [];\nexport function SplashScreen() {\n  useGlobalSplash();\n  React.useEffect(function () {\n    console.warn(\"The <SplashScreen /> component is deprecated. Use `SplashScreen.preventAutoHideAsync()` and `SplashScreen.hideAsync` from `expo-router` instead.\");\n  }, []);\n  return null;\n}\nfunction useGlobalSplash() {\n  var stack = React.useRef(null);\n  React.useEffect(function () {\n    stack.current = SplashScreen._pushEntry();\n    return function () {\n      if (stack.current) {\n        SplashScreen._popEntry(stack.current);\n      }\n    };\n  }, []);\n}\nSplashScreen.hideAsync = function () {\n  forceHideAsync();\n  globalStack.length = 0;\n};\nvar _userControlledAutoHideEnabled = false;\nvar _preventAutoHideAsyncInvoked = false;\nexport var _internal_preventAutoHideAsync = function _internal_preventAutoHideAsync() {\n  var _ErrorUtils;\n  if (_preventAutoHideAsyncInvoked) {\n    return;\n  }\n  _preventAutoHideAsyncInvoked = true;\n  if (Platform.OS !== \"web\" && (_ErrorUtils = ErrorUtils) != null && _ErrorUtils.getGlobalHandler) {\n    var originalHandler = ErrorUtils.getGlobalHandler();\n    ErrorUtils.setGlobalHandler(function (error, isFatal) {\n      SplashScreen.hideAsync();\n      originalHandler(error, isFatal);\n    });\n  }\n  SplashModule.preventAutoHideAsync();\n};\nexport var _internal_maybeHideAsync = function _internal_maybeHideAsync() {\n  if (_userControlledAutoHideEnabled) {\n    return;\n  }\n  SplashScreen.hideAsync();\n};\nfunction forceHideAsync() {\n  return _forceHideAsync.apply(this, arguments);\n}\nfunction _forceHideAsync() {\n  _forceHideAsync = _asyncToGenerator(function* () {\n    return SplashModule.hideAsync().catch(function (error) {\n      if (_preventAutoHideAsyncInvoked && error.message.includes(\"No native splash screen registered for \")) {\n        return;\n      }\n      throw error;\n    });\n  });\n  return _forceHideAsync.apply(this, arguments);\n}\nSplashScreen.preventAutoHideAsync = function () {\n  _userControlledAutoHideEnabled = true;\n  _internal_preventAutoHideAsync();\n};\nSplashScreen._pushEntry = function () {\n  var entry = nanoid();\n  globalStack.push(entry);\n  SplashScreen.preventAutoHideAsync();\n  return entry;\n};\nSplashScreen._popEntry = function (entry) {\n  var index = globalStack.indexOf(entry);\n  if (index !== -1) {\n    globalStack.splice(index, 1);\n  }\n  if (globalStack.length === 0) {\n    SplashScreen.hideAsync();\n  }\n};","map":{"version":3,"names":["SplashModule","nanoid","React","globalStack","SplashScreen","useGlobalSplash","useEffect","console","warn","stack","useRef","current","_pushEntry","_popEntry","hideAsync","forceHideAsync","length","_userControlledAutoHideEnabled","_preventAutoHideAsyncInvoked","_internal_preventAutoHideAsync","Platform","OS","ErrorUtils","getGlobalHandler","originalHandler","setGlobalHandler","error","isFatal","preventAutoHideAsync","_internal_maybeHideAsync","catch","message","includes","entry","push","index","indexOf","splice"],"sources":["C:/Users/jimpe/Desktop/react_native_apps/Portfolio2023/node_modules/expo-router/src/views/Splash.tsx"],"sourcesContent":["import * as SplashModule from \"expo-splash-screen\";\nimport { nanoid } from \"nanoid/non-secure\";\nimport * as React from \"react\";\nimport { Platform } from \"react-native\";\n\nconst globalStack: string[] = [];\n\n/**\n * A stack based component for keeping the splash screen visible.\n * Useful for stacked requests that need to be completed before the app is ready.\n * After all instances have been unmounted, the splash screen will be hidden.\n *\n * @example\n * ```tsx\n * function App() {\n *   const [isLoading, setIsLoading] = React.useState(true);\n *\n *   if (isLoading) {\n *     return <SplashScreen />\n *   }\n *\n *   return <Text>Ready!</Text>\n * }\n * ```\n */\nexport function SplashScreen() {\n  useGlobalSplash();\n  React.useEffect(() => {\n    console.warn(\n      \"The <SplashScreen /> component is deprecated. Use `SplashScreen.preventAutoHideAsync()` and `SplashScreen.hideAsync` from `expo-router` instead.\"\n    );\n  }, []);\n  return null;\n}\n\nfunction useGlobalSplash() {\n  const stack = React.useRef<string | null>(null);\n\n  React.useEffect(() => {\n    // Create a stack entry on component mount\n    stack.current = SplashScreen._pushEntry();\n    return () => {\n      if (stack.current) {\n        // Update on component unmount\n        SplashScreen._popEntry(stack.current);\n      }\n    };\n  }, []);\n}\n\nSplashScreen.hideAsync = () => {\n  forceHideAsync();\n  globalStack.length = 0;\n};\n\nlet _userControlledAutoHideEnabled = false;\nlet _preventAutoHideAsyncInvoked = false;\n\n// Expo Router uses this internal method to ensure that we can detect if the user\n// has explicitly opted into preventing the splash screen from hiding. This means\n// they will also explicitly hide it. If they don't, we will hide it for them after\n// the navigation render completes.\nexport const _internal_preventAutoHideAsync = () => {\n  // Memoize, this should only be called once.\n  if (_preventAutoHideAsyncInvoked) {\n    return;\n  }\n  _preventAutoHideAsyncInvoked = true;\n  // Append error handling to ensure any uncaught exceptions result in the splash screen being hidden.\n  if (Platform.OS !== \"web\" && ErrorUtils?.getGlobalHandler) {\n    const originalHandler = ErrorUtils.getGlobalHandler();\n    ErrorUtils.setGlobalHandler((error, isFatal) => {\n      SplashScreen.hideAsync();\n      originalHandler(error, isFatal);\n    });\n  }\n  SplashModule.preventAutoHideAsync();\n};\n\nexport const _internal_maybeHideAsync = () => {\n  // If the user has explicitly opted into preventing the splash screen from hiding,\n  // we should not hide it for them. This is often used for animated splash screens.\n  if (_userControlledAutoHideEnabled) {\n    return;\n  }\n  SplashScreen.hideAsync();\n};\n\nasync function forceHideAsync() {\n  return SplashModule.hideAsync().catch((error: any) => {\n    // Hide this very unfortunate error.\n    if (\n      // Only throw the error is something unexpected happened.\n      _preventAutoHideAsyncInvoked &&\n      error.message.includes(\"No native splash screen registered for \")\n    ) {\n      return;\n    }\n    throw error;\n  });\n}\n\nSplashScreen.preventAutoHideAsync = () => {\n  _userControlledAutoHideEnabled = true;\n  _internal_preventAutoHideAsync();\n};\n\nSplashScreen._pushEntry = (): any => {\n  const entry = nanoid();\n  globalStack.push(entry);\n  SplashScreen.preventAutoHideAsync();\n  return entry;\n};\n\nSplashScreen._popEntry = (entry: string) => {\n  const index = globalStack.indexOf(entry);\n  if (index !== -1) {\n    globalStack.splice(index, 1);\n  }\n  if (globalStack.length === 0) {\n    SplashScreen.hideAsync();\n  }\n};\n\n// TODO: Add some detection for if the splash screen is visible\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}